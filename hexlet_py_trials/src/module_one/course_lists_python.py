# Приложение 1
# Реализуйте функцию compare_version(), которая сравнивает переданные версии
# version1 и version2. Если version1 > version2, то функция должна вернуть 1,
# если version1 < version2, то -1, если же version1 = version2 — 0.


def compare_version(ver_one: str, ver_two: str) -> int:
    ver_one = ver_one.split('.')
    ver_two = ver_two.split('.')

    if ver_one[0] > ver_two[0]:
        return 1
    elif ver_one[0] < ver_two[0]:
        return -1
    elif ver_one[1] > ver_two[1]:
        return 1
    elif ver_one[1] < ver_two[1]:
        return -1
    else:
        return 0


# Испытание 2
# Реализуйте функцию length_of_last_word(), которая возвращает длину последнего
# слова переданной на вход строки. Словом считается любая последовательность не
# содержащая пробелы, символы перевода строки \n и табуляции \t.


def length_of_last_word(string: str) -> int:
    words = string.split()

    if len(words) == 0:
        return 0
    return len(words[-1])


# Испытание 3
# Вес Хэмминга это количество единиц в двоичном представлении числа.
# Реализуйте функцию hamming_weight, которая считает вес Хэмминга.


def hamming_weight(number: int):
    return bin(number).count('1')


# Испытание 4
# Реализуйте функцию is_continuous_sequence(), которая проверяет, является ли
# переданная последовательность целых чисел возрастающей непрерывно (не имеющей
# пропусков чисел). Например, последовательность [4, 5, 6, 7] — непрерывная, а
# [0, 1, 3] — нет. Последовательность может начинаться с любого числа. Главное
# условие — отсутствие пропусков чисел. Последовательность из одного числа не
# может считаться возрастающей.


def is_continuous_sequence(numbers: list) -> bool:
    if len(numbers) < 2:
        return False
    
    for x, y in zip(numbers, numbers[1:]):
        if (y - x) != 1:
            return False
    return True

# Испытание 5
# Реализуйте функцию transposed(), которая должна принимать матрицу в виде
# списка списков и возвращать транспонированную матрицу (новый список списков).


def transposed(matrix: list) -> list:
    trans_matrix = [[] for _ in range(len(matrix[0]))]

    for row in matrix:
        for index, digit in enumerate(row):
            trans_matrix[index].append(digit)

    return trans_matrix


# Испытание 6
# Реализуйте функцию chunked, которая принимает на вход число и
# последовательность. Число задает размер чанка (куска). Функция должна вернуть
# список, состоящий из чанков указанной размерности. При этом список должен
# делиться на куски-списки, строка — на строки, кортеж — на кортежи!


def chunked(size, elements):
    result = []
    index = 0

    while index < len(elements):
        result.append(elements[index:index + size])
        index += size
    
    return result


# Испытание 7
# Реализуйте функцию rpn_calc, которая принимает список, каждый элемент
# которого содержит число или знак операции (+, -, *, /). Функция должна
# вернуть результат вычисления по обратной польской записи.
# Обратная польская нотация или постфиксная нотация — форма записи
# математических и логических выражений, в которой операнды расположены перед
# знаками операций. Выражение читается слева направо. Когда в выражении
# встречается знак операции, выполняется соответствующая операция над двумя
# ближайшими операндами, находящимися слева от знака операции. Результат
# операции заменяет в выражении последовательность её операндов и знак, после
# чего выражение вычисляется дальше по тому же правилу. Таким образом,
# результатом вычисления всего выражения становится результат последней
# вычисленной операции.

def rpn_calc(elements: list) -> float:
    ...